# ECommerceApp - Пример Event-Driven Architecture (EDA) и CQRS

## Описание

Этот проект интернет-магазина одежды реализован с использованием архитектурных паттернов Event-Driven Architecture (EDA) и Command Query Responsibility Segregation (CQRS). Вся коммуникация между компонентами системы осуществляется через брокер сообщений, что обеспечивает высокую производительность и масштабируемость.

## Как это работает

### Event-Driven Architecture (EDA)

1. **Сообщения (Messaging)**:
   - Взаимодействия между компонентами осуществляются путем обмена сообщениями.
   - Сообщения могут быть синхронными или асинхронными.
   - Сообщения передаются через брокер сообщений, такой как RabbitMQ, Kafka, или Azure Service Bus.
   - Примеры сообщений: запрос на создание заказа, уведомление о подтверждении платежа.

2. **Брокер сообщений (Message Broker)**:
   - Посредник между отправителями (producers) и получателями (consumers) сообщений.
   - Обеспечивает доставку сообщений, маршрутизацию, очереди сообщений и другие функции.
   - Примеры брокеров сообщений: RabbitMQ, Apache Kafka, Azure Service Bus.

3. **События (Events)**:
   - Система реагирует на значимые изменения состояния (события).
   - Компоненты подписываются на события и выполняют соответствующие действия.
   - Примеры событий: пользователь зарегистрировался, товар добавлен в корзину, заказ отправлен.

### Command Query Responsibility Segregation (CQRS)

1. **Команды (Commands)**:
   - Команда представляет собой операцию, которая изменяет состояние системы. Примеры команд: создание пользователя, обновление заказа, удаление продукта.
   - Команды не возвращают данных, они просто подтверждают успешное или неудачное выполнение операции.
   - Примеры команд: `CreateOrderCommand`, `UpdateProductCommand`, `DeleteUserCommand`.

2. **Запросы (Queries)**:
   - Запрос представляет собой операцию, которая извлекает данные из системы. Примеры запросов: получение списка пользователей, просмотр деталей заказа, поиск продуктов по категории.
   - Запросы не изменяют состояние системы, они только возвращают данные.
   - Примеры запросов: `GetOrderByIdQuery`, `GetAllProductsQuery`, `GetUserByEmailQuery`.

3. **Разделение ответственности**:
   - В CQRS архитектуре команды и запросы обрабатываются раздельно, что позволяет оптимизировать производительность каждого из них.
   - Команды и запросы могут иметь разные модели данных и использовать разные базы данных для чтения и записи.
   - Примеры использования: командная часть может использовать реляционную базу данных для обеспечения целостности данных, тогда как часть запросов может использовать NoSQL базу данных для быстрого чтения.

### Пример работы системы

```plaintext
+-----------+        +-------------+        +-----------+
| Producer  | -----> | Message     | -----> | Consumer  |
| (Команда) |        | Broker      |        | (Запрос)  |
+-----------+        +-------------+        +-----------+
```
### Пример работы CQRS
```plaintext
+------------+      +---------------+      +-------------+
| Command    |----->| Command       |----->| Write       |
|            |      | Handler       |      | Database    |
+------------+      +---------------+      +-------------+

+----------+         +--------------+       +-------------+
| Query    |-------->| Query        |------>| Read        |
|          |         | Handler      |       | Database    |
+----------+         +--------------+       +-------------+
```
### Преимущества
**Масштабируемость:**

- __Горизонтальное масштабирование:__ Легкость добавления новых узлов и серверов в систему для обработки увеличивающихся объемов данных и запросов. Например, можно легко добавить дополнительные экземпляры сервисов для обработки команд и запросов.

- __Разделение нагрузки:__ Возможность разделить нагрузку между разными компонентами системы, что позволяет им работать более эффективно и быстрее реагировать на запросы.

- __Изоляция компонент:__ Каждый компонент системы может масштабироваться независимо, что уменьшает влияние одного компонента на другие.

**Слабая связность:**

- __Замена компонентов:__ Легкость замены и обновления отдельных компонентов системы без необходимости значительных изменений в других частях системы. Например, можно легко обновить реализацию команды без влияния на запросы.

- __Модульность:__ Система состоит из отдельных модулей, которые могут быть разработаны, протестированы и развернуты независимо друг от друга.

- __Повторное использование:__ Компоненты могут быть переиспользованы в других проектах или системах, что снижает затраты на разработку и поддержку.

**Гибкость:**

- __Изменения и расширения:__ Упрощение внесения изменений и расширения функциональности системы. Например, можно легко добавить новые типы команд или событий, не нарушая существующие процессы.

- __Быстрое реагирование на требования:__ Возможность быстро адаптироваться к изменяющимся требованиям бизнеса или пользователя.

- __Поддержка различных технологий:__ Возможность использовать разные технологии для реализации различных частей системы, например, реляционные базы данных для команд и NoSQL базы данных для запросов.

### Недостатки
**Сложность:**

- __Усложненная архитектура:__ Увеличение общей сложности системы из-за необходимости управления большим количеством компонентов и их взаимодействиями.

- __Координация:__ Необходимость координации различных команд и событий, что может потребовать дополнительных усилий и инструментов.

**Отладка:**

- __Многочисленные компоненты:__ Трудности в отладке и мониторинге событий и команд из-за большого количества участвующих компонентов.

- __Трассировка событий:__ Необходимость отслеживания и логирования событий для понимания полного жизненного цикла данных и выявления проблем.

**Задержки:**

- __Асинхронные процессы:__ Потенциальные задержки в доставке сообщений и выполнении команд при высокой нагрузке на систему.

- __Сетевые задержки:__ Возможные задержки, связанные с передачей сообщений по сети между компонентами.